<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PostgreSQL + tmpfs</title>
<meta name="generator" content="Org Mode" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">PostgreSQL + tmpfs</h1>
<p>
I have heard a couple of times that you use Temporary File
System (tmpfs) to store data in volatile memory instead of persisting
data to your storage device. Intuitively you assume that this will
always give us <span class="underline"><b><i>BLAZINGLY FAST</i></b></span> IO, right?
</p>
<div id="outline-container-org944d39e" class="outline-2">
<h2 id="org944d39e">Context</h2>
<div class="outline-text-2" id="text-org944d39e">
<p>
Say you have some small database (&lt;500MB) and the workload on such
database leans heavily on read side of operations.
</p>

<p>
I thought to myself, what if we spin a read-only replica via streaming
replication with <code>tmpfs</code>?
</p>

<p>
Something like this:
</p>


<div id="orgcb53a22" class="figure">
<p><img src="read-arch.svg" alt="read-arch.svg" class="org-svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-org1975dde" class="outline-2">
<h2 id="org1975dde">Setup</h2>
<div class="outline-text-2" id="text-org1975dde">
<p>
Creating the master database.
</p>

<p>
As <code>postgres</code> user:
</p>
<div class="org-src-container">
<pre class="src src-sh" id="orgb7870e7">mkdir --parents /var/lib/postgres/16/wal_archive

<span style="color: #7f0000;"># </span><span style="color: #7f0000;">Create database
</span>initdb --auth-local=trust /var/lib/postgres/16/master

<span style="color: #7f0000;"># </span><span style="color: #7f0000;">Helper function to edit postgresql.conf
</span><span style="color: #0031a9;">function</span> <span style="color: #602938;">set_prop</span>() { <span style="color: #00598b;">\</span>
  sed --regexp-extended <span style="color: #00598b;">\</span>
      --in-place <span style="color: #00598b;">\</span>
      <span style="color: #00598b;">"s,^#$1.*?$,$1 = $2,gI"</span> <span style="color: #00598b;">\</span>
      /var/lib/postgres/16/master/postgresql.conf; <span style="color: #00598b;">\</span>
}

<span style="color: #7f0000;"># </span><span style="color: #7f0000;">Edit relevant postgresql.conf properties
</span>set_prop wal_level replica
set_prop archive_mode on
set_prop archive_command <span style="color: #00598b;">"'test ! -f /var/lib/postgres/16/wal_archive/%f \&amp;\&amp; cp %p /var/lib/postgres/16/wal_archive/%f'"</span>
set_prop restore_command <span style="color: #00598b;">"'cp /var/lib/postgres/16/wal_archive/%f %p'"</span>
set_prop archive_cleanup_command <span style="color: #00598b;">"'pg_archivecleanup /var/lib/postgres/16/wal_archive %r'"</span>
set_prop primary_conninfo <span style="color: #00598b;">"'host=localhost port=5432 user=replicator'"</span>

<span style="color: #7f0000;"># </span><span style="color: #7f0000;">Start RDBMS
</span>pg_ctl --pgdata=/var/lib/postgres/16/master <span style="color: #00598b;">\</span>
       --log=/var/lib/postgres/16/master/log <span style="color: #00598b;">\</span>
       start

<span style="color: #7f0000;"># </span><span style="color: #7f0000;">Create replication user
</span>createuser --replication replicator
</pre>
</div>

<p>
Creating the replica with tmpfs
</p>

<p>
As <code>root</code>:
</p>
<div class="org-src-container">
<pre class="src src-sh" id="org3229db5">mkdir --parents /mnt/ramdisk
mount --types tmpfs --options=<span style="color: #00598b;">'size=8192m,mode=0700'</span> tmpfs /mnt/ramdisk
chown --recursive postgres:postgres /mnt/ramdisk
</pre>
</div>

<p>
As <code>postgres</code>:
</p>
<div class="org-src-container">
<pre class="src src-sh" id="org5402616">pg_basebackup --write-recovery-conf <span style="color: #00598b;">\</span>
              --pgdata=/mnt/ramdisk

<span style="color: #7f0000;"># </span><span style="color: #7f0000;">Start the tmpfs replica on port 5433
</span>pg_ctl --pgdata=/mnt/ramdisk    <span style="color: #00598b;">\</span>
       --options=<span style="color: #00598b;">'-c port=5433'</span> <span style="color: #00598b;">\</span>
       --log=/mnt/ramdisk/log   <span style="color: #00598b;">\</span>
       start
</pre>
</div>
</div>
</div>
<div id="outline-container-org8e6acfa" class="outline-2">
<h2 id="org8e6acfa">Benchmark</h2>
<div class="outline-text-2" id="text-org8e6acfa">
<p>
First, generate some data on the master instance as the <code>postgres</code> user:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org221f871">pgbench --port=5432    <span style="color: #00598b;">\</span>
        --initialize   <span style="color: #00598b;">\</span>
        --foreign-keys <span style="color: #00598b;">\</span>
        --scale=30     <span style="color: #00598b;">\</span>
        postgres
</pre>
</div>

<p>
see: <a href="https://www.postgresql.org/docs/current/pgbench.html">https://www.postgresql.org/docs/current/pgbench.html</a>
</p>

<p>
How many records did this generate?
</p>

<div class="org-src-container">
<pre class="src src-sql" id="orgeb72723"><span style="color: #0031a9;">select</span> to_char(<span style="color: #721045;">count</span>(*), <span style="color: #00598b;">'999,999,990'</span>) <span style="color: #0031a9;">as</span> accounts <span style="color: #0031a9;">from</span> pgbench_accounts;
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">accounts</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">3,000,000</td>
</tr>
</tbody>
</table>

<p>
We will be using the <code>select-only</code> built-in script for the benchmarks:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #7f0000;">-- </span><span style="color: #7f0000;">select-only: &lt;builtin: select only&gt;
</span>\<span style="color: #0031a9;">set</span> aid random(1, 100000 * :<span style="color: #0031a9;">scale</span>)
<span style="color: #0031a9;">SELECT</span> abalance <span style="color: #0031a9;">FROM</span> pgbench_accounts <span style="color: #0031a9;">WHERE</span> aid = :aid;
</pre>
</div>

<p>
Now, for some action, run as the <code>postgres</code> user:
</p>
<div class="org-src-container">
<pre class="src src-sh" id="orgd87b747"><span style="color: #7f0000;"># </span><span style="color: #7f0000;">change port to 5433 to run against the replica database
</span>pgbench --port=5432   <span style="color: #00598b;">\</span>
        --time=60     <span style="color: #00598b;">\</span>
        --client=100  <span style="color: #00598b;">\</span>
        --jobs=3      <span style="color: #00598b;">\</span>
        --select-only <span style="color: #00598b;">\</span>
        --no-vacuum   <span style="color: #00598b;">\</span>
        postgres
</pre>
</div>

<p>
Against the master instance:
</p>
<pre class="example" id="org8c94cf1">
pgbench (16.1)
transaction type: &lt;builtin: select only&gt;
scaling factor: 30
query mode: simple
number of clients: 100
number of threads: 3
maximum number of tries: 1
duration: 60 s
number of transactions actually processed: 5453634
number of failed transactions: 0 (0.000%)
latency average = 1.100 ms
initial connection time = 74.276 ms
tps = 90905.785932 (without initial connection time)
</pre>

<p>
Against the replica instance:
</p>
<pre class="example" id="org0815a96">
pgbench (16.1)
transaction type: &lt;builtin: select only&gt;
scaling factor: 30
query mode: simple
number of clients: 100
number of threads: 3
maximum number of tries: 1
duration: 60 s
number of transactions actually processed: 5506013
number of failed transactions: 0 (0.000%)
latency average = 1.089 ms
initial connection time = 74.259 ms
tps = 91793.918172 (without initial connection time)
</pre>

<p>
Well, that is a surprise (for me at least). I was expecting the
<code>tmpfs</code> to outperform the master database by a moderate/large
margin. It seems the PostgreSQL + Operating System (OS) caches are
doing a great job.
</p>

<p>
Let's try with a slightly bigger dataset (10x bigger).
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org776ce94">pgbench --port=5432    <span style="color: #00598b;">\</span>
        --initialize   <span style="color: #00598b;">\</span>
        --foreign-keys <span style="color: #00598b;">\</span>
        --scale=300    <span style="color: #00598b;">\</span>
        postgres
</pre>
</div>

<p>
Let's check the master database size:
</p>

<div class="org-src-container">
<pre class="src src-sql" id="org28c280f"><span style="color: #0031a9;">select</span> relname
     , pg_size_pretty(pg_relation_size(cl.oid)) <span style="color: #0031a9;">as</span> "<span style="color: #0031a9;">size</span>"
  <span style="color: #0031a9;">from</span> pg_class cl
 <span style="color: #0031a9;">where</span> cl.relnamespace = <span style="color: #00598b;">'public'</span>::regnamespace
 <span style="color: #0031a9;">order</span> <span style="color: #0031a9;">by</span> pg_relation_size(cl.oid) <span style="color: #0031a9;">desc</span>
</pre>
</div>

<pre class="example" id="orga6d002f">
| relname               | size    |
|-----------------------+---------|
| pgbench_accounts      | 3842 MB |
| pgbench_accounts_pkey | 643 MB  |
| pgbench_tellers       | 136 kB  |
| pgbench_tellers_pkey  | 88 kB   |
| pgbench_branches_pkey | 16 kB   |
| pgbench_branches      | 16 kB   |
| pgbench_history       | 0 bytes |
</pre>

<p>
Let's run again the <code>select-only</code> benchmarks! Against the master
instance:
</p>

<pre class="example" id="orge16f30c">
pgbench (16.1)
transaction type: &lt;builtin: select only&gt;
scaling factor: 300
query mode: simple
number of clients: 100
number of threads: 3
maximum number of tries: 1
duration: 60 s
number of transactions actually processed: 5146134
number of failed transactions: 0 (0.000%)
latency average = 1.165 ms
initial connection time = 86.478 ms
tps = 85832.914187 (without initial connection time)
</pre>

<p>
and against the replica instance:
</p>

<pre class="example" id="org4b7112b">
pgbench (16.1)
transaction type: &lt;builtin: select only&gt;
scaling factor: 300
query mode: simple
number of clients: 100
number of threads: 3
maximum number of tries: 1
duration: 60 s
number of transactions actually processed: 5150581
number of failed transactions: 0 (0.000%)
latency average = 1.164 ms
initial connection time = 76.838 ms
tps = 85874.008596 (without initial connection time)
</pre>

<p>
Well, our PostgreSQL instances have the default configuration mostly,
which means 128 MB of <a href="https://www.postgresql.org/docs/current/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-MEMORY">shared buffers</a>. Clearly, it is not enough cache
to perform on par with the <code>tmpfs</code> replica, considering the dataset
size of ~4.5 GB. Perhaps if I drop my OS <a href="https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics">page cache</a>?
</p>

<p>
As <code>root</code>:
</p>
<div class="org-src-container">
<pre class="src src-sh">sync; <span style="color: #721045;">echo</span> 1 &gt; /proc/sys/vm/drop_caches
</pre>
</div>

<p>
Benchmark once again versus the master instance:
</p>

<pre class="example" id="org835a0ea">
pgbench (16.1)
transaction type: &lt;builtin: select only&gt;
scaling factor: 300
query mode: simple
number of clients: 100
number of threads: 3
maximum number of tries: 1
duration: 60 s
number of transactions actually processed: 2037721
number of failed transactions: 0 (0.000%)
latency average = 2.943 ms
initial connection time = 84.288 ms
tps = 33976.877020 (without initial connection time)
</pre>

<p>
Aha! About a third of the transactions per second (TPS).
</p>

<p>
Let's run two more times in order and watch the OS cache do its job:
</p>

<pre class="example" id="org4d41361">
pgbench (16.1)
transaction type: &lt;builtin: select only&gt;
scaling factor: 300
query mode: simple
number of clients: 100
number of threads: 3
maximum number of tries: 1
duration: 60 s
number of transactions actually processed: 4475925
number of failed transactions: 0 (0.000%)
latency average = 1.341 ms
initial connection time = 70.050 ms
tps = 74598.040075 (without initial connection time)
</pre>

<pre class="example" id="org8ee695d">
pgbench (16.1)
transaction type: &lt;builtin: select only&gt;
scaling factor: 300
query mode: simple
number of clients: 100
number of threads: 3
maximum number of tries: 1
duration: 60 s
number of transactions actually processed: 5070696
number of failed transactions: 0 (0.000%)
latency average = 1.183 ms
initial connection time = 79.571 ms
tps = 84538.387397 (without initial connection time)
</pre>

<p>
Ok, now we are back at our starting TPS.
</p>
</div>
</div>
<div id="outline-container-orge37e1e7" class="outline-2">
<h2 id="orge37e1e7">Closing thoughts</h2>
<div class="outline-text-2" id="text-orge37e1e7">
<p>
I don't know anything about other platforms such as Windows and MacOS
(well, I know almost nothing about Linux too&#x2026;), so I will emit my
thoughts with a Linux + PostgreSQL combo in mind.
</p>

<p>
For long-running applications, it appears to be better to just let
PostgreSQL and Linux handle caching. While you can still benefit from
a steady number of TPS using <code>tmpfs</code> or <code>ramfs</code>, I would argue that it
is probably easier to just have a normal setup.
</p>

<p>
Now, for short-lived applications, such as running your integration
tests, it may be an explendid option. I shall explore this topic in a
later entry to this blog.
</p>

<p>
Also, please, tune your RDBMS. If you are clueless like me, the bare
minimum can be found here: <a href="https://pgtune.leopard.in.ua">https://pgtune.leopard.in.ua</a>.
</p>

<p>
If you want to contact me about this post, do so via this <a href="https://github.com/jean-lopes/blog/discussions/1">discussion</a>.
</p>
</div>
</div>
</div>
</body>
</html>
