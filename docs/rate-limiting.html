<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rate limiting</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="css/style.css" />
</head>
<body>
<div id="preamble" class="status">
<h1>Rate limiting</h1>
</div>
<div id="content" class="content">
<p>
Ever needed to rate-limit inserts? Did you consider letting your
source of truth, the database, enforce it for you? I did. Let’s
explore one unconventional but elegant<sup><i>[citation needed]</i></sup> approach.
</p>

<p>
My workload is strictly insert-only: only <code>SELECT</code> and <code>INSERT</code>, never
<code>UPDATE</code> or <code>DELETE</code>. The rate limit is equally simple, a fixed
minimum interval (cooldown) between inserts from the same user.
</p>

<p>
Imagine a table called <code>message</code> that stores chat messages sent by
users. A minimal DDL might look like this:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span class="org-keyword">create</span> <span class="org-keyword">table</span> <span class="org-function-name">message</span> (
  user_id text        <span class="org-keyword">not</span> <span class="org-keyword">null</span>,
  content text        <span class="org-keyword">not</span> <span class="org-keyword">null</span>,
  sent_at timestamptz <span class="org-keyword">not</span> <span class="org-keyword">null</span>
);
</pre>
</div>

<p>
A straightforward solution is a <code>BEFORE INSERT</code> trigger that checks
whether the user is still on cooldown. I’m not a simple man though, so
here we are.
</p>

<p>
Can we enforce the cooldown without an explicit check? Yes, by
combining two powerful PostgreSQL features:
</p>

<ul class="org-ul">
<li><a href="https://www.postgresql.org/docs/current/rangetypes.html">Range types</a> (specifically <code>tstzrange</code>)</li>
<li>Exclusion constraints backed by a GiST index</li>
</ul>

<p>
Exclusion constraints guarantee that no two rows have overlapping
values for the specified expression(s). PostgreSQL 18 made the syntax
for “no overlaps” much cleaner with the <code>WITHOUT OVERLAPS</code> clause.
</p>

<p>
The idea is simple: give each message a half-open time range <code>[now(),
now() + cooldown)</code> that belongs exclusively to that user.  Because the
exclusion constraint prevents overlapping ranges for the same
<code>user_id</code>, a second insert within the cooldown window is rejected at
the constraint level, no trigger required.
</p>

<p>
Here’s the complete DDL:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span class="org-keyword">drop</span> <span class="org-keyword">table</span> <span class="org-function-name">if</span> <span class="org-keyword">exists</span> message;

<span class="org-keyword">create</span> <span class="org-keyword">table</span> <span class="org-function-name">message</span> (
  user_id         text        <span class="org-keyword">not</span> <span class="org-keyword">null</span>,
  content         text        <span class="org-keyword">not</span> <span class="org-keyword">null</span>,
  sent_at         timestamptz <span class="org-keyword">not</span> <span class="org-keyword">null</span> <span class="org-keyword">default</span> now(),
  cooldown_period tstzrange   <span class="org-keyword">not</span> <span class="org-keyword">null</span> <span class="org-keyword">default</span> tstzrange(
    now(), now() + <span class="org-type">interval</span> <span class="org-string">'30 seconds'</span>,
    <span class="org-string">'[)'</span>
  ),

  <span class="org-keyword">unique</span> ( user_id, cooldown_period <span class="org-keyword">without</span> <span class="org-keyword">overlaps</span> )
);
</pre>
</div>

<p>
Let’s test it:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span class="org-keyword">insert</span> <span class="org-keyword">into</span> message (user_id, content)
<span class="org-keyword">values</span> (<span class="org-string">'bananilson'</span>, <span class="org-string">'nada acontece feijoada'</span>);

<span class="org-comment-delimiter">-- </span><span class="org-comment">this second insert happens immediately,
</span><span class="org-comment-delimiter">-- </span><span class="org-comment">still inside the 30-second window
</span><span class="org-keyword">insert</span> <span class="org-keyword">into</span> message (user_id, content)
<span class="org-keyword">values</span> (<span class="org-string">'bananilson'</span>, <span class="org-string">'supimpa'</span>);
</pre>
</div>

<p>
The second insert fails with:
</p>

<pre class="example" id="org0aae48d">
ERROR: conflicting key value violates exclusion constraint
"message_user_id_cooldown_period_key"
</pre>

<p>
After 30 seconds (or whatever interval you choose), the next message
from the same user succeeds again.
</p>

<p>
That’s it! With a single declarative constraint we get:
</p>

<ul class="org-ul">
<li>Atomic, race-condition-free rate limiting;</li>
<li>No application-level locking or querying;</li>
<li>Enforcement at the only true source of truth.</li>
</ul>

<p>
That's all, folks.
</p>
</div>
<div id="postamble" class="status">
<p><small>2025-12-12</small></p>
</div>
</body>
</html>
